# 1. 单例模式
一个类仅有一个实例
```js
// 静态属性形式
class Person {
  show() {
    console.log('我是单例模式')
  }

  static setInstance() {
    if (!Person.instance) {
      Person.instance = new Person()
    }
    return Person.instance
  }
}

// 闭包模式
Person.setInstance = (function() {
    let instance = null
    return function() {
      if (!instance) {
        instance = new Person()
      }
      return instance
    }
})()

```

### Vuex中的单例模式
与上面的`setInstance`相似

```js
let Vue // 这个Vue的作用和楼上的instance作用一样
...
export function install (_Vue) {
  // 判断传入的Vue实例对象是否已经被install过Vuex插件（是否有了唯一的state）
  if (Vue && _Vue === Vue) {
    if (process.env.NODE_ENV !== 'production') {
      console.error(
        '[vuex] already installed. Vue.use(Vuex) should be called only once.'
      )
    }
    return
  }
  // 若没有，则为这个Vue实例对象install一个唯一的Vuex
  Vue = _Vue
  // 将Vuex的初始化逻辑写进Vue的钩子函数里
  applyMixin(Vue)
}
```

> 单例模式保证每一个Vue实例只会被install一次Vuex插件，所以每个 Vue 实例只会拥有一个全局的 Store。如果没有单例模式会造成数据丢失，每次都会在当前vue实例注入新的store

# 原型模式
原型模式不仅是一种设计模式，它还是一种`编程范式`，是js面向对象系统实现的根基。

# 装饰器模式
在`不改变原对象`的基础上，通过对其进行包装拓展，使原有对象可以满足用户的更复杂需求。

es5实现
```javascript
const Modal = (function() {
    let modal = null
    return function() {
        if (!modal) {
            modal = document.createElment('div')
            modal.innerHTML = '您还未登录哦'
            modal.id = 'modal'
            modal.style.display = 'none'
            document.body.appendChild(modal)
        }
        return modal
    }
})()

document.getElementById('open').addEventListener('click', function() {
    openModal()
    changeButtonStatus()
})

document.getElementById('close').addEventListener('click', function() {
    let modal = new Modal()
    modal.style.display = 'none'
})
// 将展示Modal的逻辑单独封装
function openModal() {
    const modal = new Modal()
    modal.style.display = 'block'
}
// 新功能
function newFunction1 () {
      const btn = document.getElementById('open')
      btn.innerText = '快去登录'
}
function newFunction2 () {
    const btn =  document.getElementById('open')
    btn.setAttribute("disabled", true)
}
// 新版本功能逻辑整合
function changeButtonStatus() {
    changeButtonText()
    disableButton()
}

```

es6实现
```javascript
// 定义打开按钮
class OpenButton {
    onClick() {
        const modal = new Modal()
        modal.style.display = 'block'
    }
}

// 定义按钮对应的装饰器
class Decorator {
    constructor(open_button) {
            this.open_button = open_button
        }
    }
    onClick() {
        this.open_button.onClick()
        // "包装"了一层新逻辑
        this.changeButtonStatus()
    }
    changeButtonStatus() {
        this.changeButtonText()
        this.disableButton()
    }
    disableButton() {
        const btn =  document.getElementById('open')
        btn.setAttribute("disabled", true)
    }
    changeButtonText() {
        const btn = document.getElementById('open')
        btn.innerText = '快去登录'
    }
}
const openButton = new OpenButton()
const decorator = new Decorator(openButton)

document.getElementById('open').addEventListener('click', function() {
    // openButton.onClick()
    // 此处可以分别尝试两个实例的onClick方法，验证装饰器是否生效
    decorator.onClick()
})
```

es7实现
```javascript

```

# 策略模式
将臃肿的if-else模式进行业务拆分，提取逻辑，分发优化
比如将下面逻辑

逻辑分析：现有sm，mid，max三种获取n值方式，通过不同的tag获取不同的值
- 0 - 5 之间返回原值n
- 5 - 10 之间返回原值n - 1
- 10 - 100 之间返回原值 n - 2
- 
```javascript
function transfer(tag, n) {
  if (tag === 'min') {
    if (n > 0 & n <= 5) {
      return n
    }
  }
  if (tag === 'mid') {
    if (n > 5 & n <= 10) {
      return n - 1
    }
  }
  if (tag === 'max') {
    if (n > 10 & n <= 100) {
      return n - 2
    }
  }
}
```

将内部各个函数体进行提取，用map管理逻辑体

```javascript
const numberProcessor = {
  sm(n) {
    if (n > 0 & n <= 5) {
      return n
    }
  },
  mid(n) {
    if (n > 5 & n <= 10) {
      return n - 1
    }
  }
  max(n) {
    if (n > 10 & n <= 100) {
      return n - 1
    }
  }
}

const numberDone = (tag, n) => {
  return numberProcessor[tag](n)
}
```