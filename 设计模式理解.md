游离在设计模式中的`开放封闭原则`： 
软件实体应该是`可扩展`，而`不可修改`的。也就是说，对扩展是开放的，而对修改是封闭的。
因此，开放封闭原则主要体现在两个方面：
- 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。
- 对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。

# 1. 单例模式
一个类仅有一个实例
```js
// 静态属性形式
class Person {
  show() {
    console.log('我是单例模式')
  }

  static setInstance() {
    if (!Person.instance) {
      Person.instance = new Person()
    }
    return Person.instance
  }
}

// 闭包模式
Person.setInstance = (function() {
    let instance = null
    return function() {
      if (!instance) {
        instance = new Person()
      }
      return instance
    }
})()

```

### Vuex中的单例模式
与上面的`setInstance`相似

```js
let Vue // 这个Vue的作用和楼上的instance作用一样
...
export function install (_Vue) {
  // 判断传入的Vue实例对象是否已经被install过Vuex插件（是否有了唯一的state）
  if (Vue && _Vue === Vue) {
    if (process.env.NODE_ENV !== 'production') {
      console.error(
        '[vuex] already installed. Vue.use(Vuex) should be called only once.'
      )
    }
    return
  }
  // 若没有，则为这个Vue实例对象install一个唯一的Vuex
  Vue = _Vue
  // 将Vuex的初始化逻辑写进Vue的钩子函数里
  applyMixin(Vue)
}
```

> 单例模式保证每一个Vue实例只会被install一次Vuex插件，所以每个 Vue 实例只会拥有一个全局的 Store。如果没有单例模式会造成数据丢失，每次都会在当前vue实例注入新的store

# 原型模式
原型模式不仅是一种设计模式，它还是一种`编程范式`，是js面向对象系统实现的根基。

# 装饰器模式
在`不改变原对象`的基础上，通过对其进行包装拓展，使原有对象可以满足用户的更复杂需求。

es5实现
```javascript
const Modal = (function() {
    let modal = null
    return function() {
        if (!modal) {
            modal = document.createElment('div')
            modal.innerHTML = '您还未登录哦'
            modal.id = 'modal'
            modal.style.display = 'none'
            document.body.appendChild(modal)
        }
        return modal
    }
})()

document.getElementById('open').addEventListener('click', function() {
    openModal()
    changeButtonStatus()
})

document.getElementById('close').addEventListener('click', function() {
    let modal = new Modal()
    modal.style.display = 'none'
})
// 将展示Modal的逻辑单独封装
function openModal() {
    const modal = new Modal()
    modal.style.display = 'block'
}
// 新功能
function newFunction1 () {
      const btn = document.getElementById('open')
      btn.innerText = '快去登录'
}
function newFunction2 () {
    const btn =  document.getElementById('open')
    btn.setAttribute("disabled", true)
}
// 新版本功能逻辑整合
function changeButtonStatus() {
    changeButtonText()
    disableButton()
}

```

es6实现
```javascript
// 定义打开按钮
class OpenButton {
    onClick() {
        const modal = new Modal()
        modal.style.display = 'block'
    }
}

// 定义按钮对应的装饰器
class Decorator {
    constructor(open_button) {
            this.open_button = open_button
        }
    }
    onClick() {
        this.open_button.onClick()
        // "包装"了一层新逻辑
        this.changeButtonStatus()
    }
    changeButtonStatus() {
        this.changeButtonText()
        this.disableButton()
    }
    disableButton() {
        const btn =  document.getElementById('open')
        btn.setAttribute("disabled", true)
    }
    changeButtonText() {
        const btn = document.getElementById('open')
        btn.innerText = '快去登录'
    }
}
const openButton = new OpenButton()
const decorator = new Decorator(openButton)

document.getElementById('open').addEventListener('click', function() {
    // openButton.onClick()
    // 此处可以分别尝试两个实例的onClick方法，验证装饰器是否生效
    decorator.onClick()
})
```

es7实现
```javascript

```

# 策略模式
将臃肿的if-else模式进行业务拆分，提取逻辑，分发优化
比如将下面逻辑

逻辑分析：现有sm，mid，max三种获取n值方式，通过不同的tag获取不同的值
- 0 - 5 之间返回原值n
- 5 - 10 之间返回原值n - 1
- 10 - 100 之间返回原值 n - 2
- 
```javascript
function transfer(tag, n) {
  if (tag === 'min') {
    if (n > 0 & n <= 5) {
      return n
    }
  }
  if (tag === 'mid') {
    if (n > 5 & n <= 10) {
      return n - 1
    }
  }
  if (tag === 'max') {
    if (n > 10 & n <= 100) {
      return n - 2
    }
  }
}
```

将内部各个函数体进行提取，用map管理逻辑体

```javascript
const numberProcessor = {
  sm(n) {
    if (n > 0 & n <= 5) {
      return n
    }
  },
  mid(n) {
    if (n > 5 & n <= 10) {
      return n - 1
    }
  }
  max(n) {
    if (n > 10 & n <= 100) {
      return n - 1
    }
  }
}

const numberDone = (tag, n) => {
  return numberProcessor[tag](n)
}
```

# 状态模式
状态模式和策略模式很像，解决的问题没啥本质的差别，它们都封装行为、都通过委托来实现行为分发

但`策略模式`中的行为函数是”潇洒“的行为函数，它们不依赖调用主体、互相平行、各自为政，井水不犯河水。

而`状态模式`中的行为函数，首先是和状态主体之间存在着关联，由状态主体把它们串在一起；另一方面，正因为关联着同样的一个（或一类）主体，所以不同状态对应的行为函数可能并不会特别割裂。即**`允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。`**


逻辑分析：四种咖啡的咖啡机体内，蕴含着四种状态：
- 美式咖啡态（american)：只吐黑咖啡
- 普通拿铁态(latte)：黑咖啡加点奶
- 香草拿铁态（vanillaLatte）：黑咖啡加点奶再加香草糖浆
- 摩卡咖啡态(mocha)：黑咖啡加点奶再加点巧克力

```javascript
class CoffeeMaker {
  constructor() {
    this.state = 'init' // 初始化咖啡机状态
  }

  changeState(state) {
    this.state = state
    if (state === 'american') {
      console.log('制作黑咖啡')
    } else if (state === 'latte') {
      console.log('黑咖啡加点奶')
    } else if (state === 'vanillaLatte') {
      console.log('黑咖啡加点奶再加点香草糖浆')
    } else if (state === 'mocha') {
      console.log('黑咖啡加点奶再加点巧克力')
    }
  }
}

const mk = new CoffeeMaker();
mk.changeState('latte'); // 输出 '黑咖啡加点奶'

```

通过状态模式实现，状态模式需要对函数主体状态有感知（需要随时都可以拿到函数主体中的各个属性）

```javascript
class CoffeeMaker {
  constructor() {
    this.state = 'init' // 初始化咖啡模式
    this.leftMilk = '500ml' // 初始化牛奶存储量
  }
  stateProcceror = {
    that: this, // 拿到主体，后续可以任何时候获取主体的属性
    american() {
      // 尝试在行为函数里拿到咖啡机实例的信息并输出
      console.log('咖啡机现在的牛奶存储量是:', this.that.leftMilk)
      console.log('制作黑咖啡')
    },
    latte() {
      this.american()
      console.log('加点奶')
    },
    vanillaLatte() {
      this.latte();
      console.log('再加香草糖浆')
    },
    mocha() {
      this.latte();
      console.log('再加巧克力')
    }
  }
  changeState(state) {
    this.state = state
    const fn = this.stateProcceror[state]
    if (!fn) return
    fn()
  }
}

const mk = new CoffeeMaker()
mk.changeState('latte')
```
