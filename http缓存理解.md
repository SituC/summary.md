# 强制缓存
强制缓存有两个服务器响应报文来控制，`expires`和`cache-control`

- expires: 服务器资源过期时间，因为会存在服务器时间与客户端时间不同的问题，所以一般弃用
- cache-control: 
  - `private`: 客户端可以缓存。
  - `public`: 客户端和代理服务器可以缓存  
  - `max-age=t`: 资源会在t秒后失效
  - `no-cache`: 使用协商缓存
  - `no-store`: 不适用缓存
  - `immutable`: 相应内容将一直不会改变，一般和max-age共同使用，对缓存生命周期控制的互补性属性，有了此属性客户端就不会再向服务端发送验证请求。因此客户端不应发送重新验证请求头（例如If-None-Match或If-Modified-Since）来检查更新，即使用户显式地刷新页面

```Cache-Control: max-age=365000000, immutable```

# 协商缓存
当cache-control为no-cache时启用协商缓存。协商缓存需要对比判断标识是否可以使用缓存。

- 第一次请求，服务器返回缓存标识以及数据，客户端将标识和数据备份到缓存中
- 第二次请求，客户端将缓存标识发送给服务器，由服务器判断是否失效
  - `未失效` 返回304状态码，浏览器拿到状态码可以直接使用缓存数据库中的缓存数据
  - `已失效` 重复第一次请求操作

## 两种协商缓存方案

### `Last-Modified`
服务器在响应请求时，会告诉浏览器资源的最后修改时间。

`if-Modified-Since`: 浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回304和响应报文头，浏览器只需要从缓存中获取信息即可。从字面上看，就是说：从某个时间节点算起，是否文件被修改了

- `被修改`：那么开始传输响应一个整体，服务器返回：200 OK
- `未修改`：那么只需传输响应header，服务器返回：304 Not Modified

`if-Unmodified-Since`: 从某个时间点算起, 是否文件没有被修改

- `未修改`: 则开始`继续'传送文件: 服务器返回: 200 OK
- `被修改`：则不传输,服务器返回: 412 Precondition failed (预处理错误)

这两个的区别是一个是修改了才下载一个是没修改才下载。
Last-Modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1推出了`Etag`。

# Etag
`Etag`： 服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）

`If-None-Match`： 再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现If-None-Match则与被请求资源的唯一标识进行对比。

- 不同，说明资源被改动过，则响应整个资源内容，返回状态码200。
- 相同，说明资源无心修改，则响应header，浏览器直接从缓存中获取数据信息。返回状态码304.

但是实际应用中由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用Etag了。

# 缓存的优点

- 减少了冗余的数据传递，节省宽带流量
- 减少了服务器的负担，大大提高了网站性能
- 加快了客户端加载网页的速度 这也正是HTTP缓存属于客户端缓存的原因。